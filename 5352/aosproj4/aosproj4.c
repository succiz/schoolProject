/**************************************************************************************************************************
 * Programmer: Shuyi Zhao
 * Advanced Operating Systems
 * Programming Project #4: Chang and Robert's Leader Election Algorithm
 * Due date: Dec 4th, 2012
 * Instructor: Dr. Ajay K. Katangur
 **************************************************************************************************************************
 * Program Description: Write a C or C++ program named election.c or election.cpp (executable name should be election) 
 *                      to implement the Chang and Robert's Leader Election Algorithm using MPI.
***************************************************************************************************************************/

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NONPARTICIPANT 0
#define PARTICIPANT    1

void get_id(int rank, int* id);
void chang_robert(int rank, int size, int* id, int right, int left, int* count, int* flag, int* election, int* elected, int* state_status, MPI_Request requests, MPI_Status status);

//********************************************************************
//
// main Function
//
// This function performs main function, calls the other functions
//
// Return Value
// ------------
// 0                         
//
// Global Variables
// ---------------
// rank                     INT							MPI processor ID
// size                     INT                         MPI processor numbers
// id                       INT                         The id of processor generated by random
// right                    INT                         The right neighbor of processor
// left                     INT                         The left neighbor of processor
// state_status             INT                         Define the participation of a processor
// count                    INT                         Count how many phase the processor has been through
// election                 INT*                        The election message array
// elected                  INT*                        The elected message array
// requests                 MPI_REQUEST                 The MPI requests in unblocking message
// status                   MPI_STATUS                  The MPI status
// flag                     INT                         The MPI flags used in MPI_Test
// k                        INT                         The integer for loop counting
//*******************************************************************
int main(int argc, char* argv[])
{
	int rank;
    int size;
	int id;
	int right;
	int left;
	int state_status;
	int count;
	int* election;
	int* elected;
    MPI_Request requests;
	MPI_Status status;
	int* flag;
	int k;


    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
	
	right = (rank + 1) % size; // right rank
    left = (size + rank - 1) % size; // left rank
	count = 0;
	state_status = NONPARTICIPANT;
	election = (int*)malloc(2);
	elected = (int*)malloc(2);
	flag = (int*)malloc(size);
	election[1] = -1; 
	elected[1] = -1;
	for (k=0; k<size; k++)
		flag[k] = 0;
    
    if(size <= 3)
    {
       printf("The number of processors should be greater than 3.\n");
       MPI_Finalize();
       return 0;
    }
	
	if (atoi(argv[1]) < 0 || atoi(argv[1]) > size)
	{
		printf("The number of initial process to start election should be between 0 and %d.\n", size);
		MPI_Finalize();
		return 0; 
	}
	
	get_id(rank, &id);
	MPI_Barrier( MPI_COMM_WORLD ); 

	
	if (rank == atoi(argv[1]))
	{
		state_status = PARTICIPANT;
		election[0] = id;
		MPI_Send(election, 1, MPI_INT, right, 100, MPI_COMM_WORLD);
		printf("Processor %d is initiating the election and sending the number %d to processor %d.\n", rank, id, right);
		fflush(stdout);
	}
	
    sleep(1);
    
	while(elected[1] == -1)
		chang_robert(rank, size, &id, right, left, &count, flag, election, elected, &state_status, requests, status);
            
    MPI_Finalize();
    return 0; 
	
}

//********************************************************************
//
// Get Id function
//
// This function generates the different ids for the processors
//
// Return Value
// ------------
// void                         
//
//
// Reference Parameters
// --------------------
// rank                     INT				            MPI processor rank number
// id                       INT*                        MPI processor random id
//
// Local Variables
// ---------------
// NONE
//*******************************************************************
void get_id(int rank, int* id)
{
	sleep(rank);
	srand(time(NULL));
    *id = rand();
	printf("Initially Rank:  %d, Identifier: %d. \n", rank, *id);
	fflush(stdout);
}

//********************************************************************
//
// Chang Robert's algorithm function
//
// This function performs Chang and Robert's algrithom
//
// Return Value
// ------------
// void                         
//
//
// Reference Parameters
// --------------------
// rank                     INT				            MPI processor rank number
// id                       INT*                        MPI processor random id
// size                     INT                         MPI processor numbers
// right                    INT                         The right neighbor of processor
// left                     INT                         The left neighbor of processor
// state_status             INT                         Define the participation of a processor
// count                    INT                         Count how many phase the processor has been through
// election                 INT*                        The election message array
// elected                  INT*                        The elected message array
// requests                 MPI_REQUEST                 The MPI requests in unblocking message
// status                   MPI_STATUS                  The MPI status
// flag                     INT                         The MPI flags used in MPI_Test
//
// Local Variables
// ---------------
// NONE
//*******************************************************************
void chang_robert(int rank, int size, int* id, int right, int left, int* count, int* flag, int* election, int* elected, int* state_status, MPI_Request requests, MPI_Status status)
{
	MPI_Irecv(election, 2, MPI_INT, left, 100, MPI_COMM_WORLD, &requests);
    
	MPI_Test(&requests, &flag[left], &status);
	while (!flag[left])
		MPI_Test(&requests, &flag[left], &status);

	if (election[1] == -1)
	{
		*count++;

		if (election[0] > *id)
		{
			printf("Phase: %d, Rank:  %d, Identifier: %d, Status: Passive\n", *count+1, rank, *id);
			fflush(stdout);

			if (*state_status == NONPARTICIPANT)
				*state_status = PARTICIPANT;
			MPI_Send(election, 2, MPI_INT, right, 100, MPI_COMM_WORLD);
		}
		else if (election[0] < *id)
		{
			printf("Phase: %d, Rank:  %d, Identifier: %d, Status: Active\n", *count+1, rank, *id);
			fflush(stdout);

			if (*state_status == NONPARTICIPANT)
			{
				*state_status = PARTICIPANT; 
				election[0] = *id;
				MPI_Send(election, 2, MPI_INT, right, 100, MPI_COMM_WORLD);
			}	
		}
		else
		{
            printf("Phase: %d, Rank:  %d, Identifier: %d, Status: Active\n", *count+1, rank, *id);
            fflush(stdout);

			*state_status = NONPARTICIPANT;
			election[1] = rank;
			MPI_Send(election, 2, MPI_INT, right, 100, MPI_COMM_WORLD);	
			fflush(stdout);
		}
	}
	else
	{
		elected[0] = election[0];
		elected[1] = election[1];
		election = NULL;

		if (elected[0] != *id)
		{
			*state_status = NONPARTICIPANT;
			MPI_Send(elected, 2, MPI_INT, right, 100, MPI_COMM_WORLD);
		}
        
		else if(elected[0] == *id)
        {
			printf("I am the Leader and my Rank is: %d and my Identifier is: %d\n", rank, *id);
            fflush(stdout);
        }

	}
}
